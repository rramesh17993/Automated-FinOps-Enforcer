package notifications
package notifications

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"





















































































































































































































}	return fmt.Sprintf("%d days %d hours", days, remainingHours)		}		return fmt.Sprintf("%d days", days)	if remainingHours == 0 {		remainingHours := hours % 24	days := hours / 24		}		return fmt.Sprintf("%d hours", hours)	if hours < 24 {		hours := int(d.Hours())func formatDuration(d time.Duration) string {// formatDuration formats a duration in human-readable form}	Style string `json:"style,omitempty"`	Value string `json:"value"`	Text  string `json:"text"`	Type  string `json:"type"`type SlackAction struct {// SlackAction represents an interactive button}	Short bool   `json:"short"`	Value string `json:"value"`	Title string `json:"title"`type SlackField struct {// SlackField represents a field in a Slack attachment}	Footer    string        `json:"footer,omitempty"`	Timestamp int64         `json:"ts,omitempty"`	Actions   []SlackAction `json:"actions,omitempty"`	Fields    []SlackField  `json:"fields,omitempty"`	Text      string        `json:"text,omitempty"`	Title     string        `json:"title,omitempty"`	Color     string        `json:"color,omitempty"`type SlackAttachment struct {// SlackAttachment represents a Slack message attachment}	Attachments []SlackAttachment  `json:"attachments,omitempty"`	Text        string             `json:"text,omitempty"`	Channel     string             `json:"channel,omitempty"`type SlackMessage struct {// SlackMessage represents a Slack webhook message}	return nil	}		return fmt.Errorf("slack api error: status=%d", resp.StatusCode)	if resp.StatusCode != http.StatusOK {	defer resp.Body.Close()	}		return fmt.Errorf("failed to send slack notification: %w", err)	if err != nil {	resp, err := s.httpClient.Do(req)	req.Header.Set("Content-Type", "application/json")	}		return fmt.Errorf("failed to create request: %w", err)	if err != nil {	req, err := http.NewRequestWithContext(ctx, "POST", s.webhookURL, bytes.NewBuffer(payload))	}		return fmt.Errorf("failed to marshal slack message: %w", err)	if err != nil {	payload, err := json.Marshal(message)func (s *SlackNotifier) sendMessage(ctx context.Context, message *SlackMessage) error {// sendMessage sends a message to Slack}	}		Attachments: []SlackAttachment{attachment},		Channel:     s.channel,	return &SlackMessage{	}		Footer:    "FinOps Enforcer",		Timestamp: time.Now().Unix(),		Text:      fmt.Sprintf("Deployment `%s` in namespace `%s` has been restored to %d replicas.", deployment, namespace, replicas),		Title:     "âœ… Resource Reactivated",		Color:     "#36a64f",	attachment := SlackAttachment{func (s *SlackNotifier) buildReactivationMessage(namespace, deployment string, replicas int32) *SlackMessage {// buildReactivationMessage constructs a Slack message for reactivation notifications}	}		Attachments: []SlackAttachment{attachment},		Channel:     s.channel,	return &SlackMessage{	}			deployment.Name, deployment.Namespace, action.OriginalReplicas)		attachment.Text += fmt.Sprintf("\n\n*To reactivate manually:*\n```kubectl scale deployment %s -n %s --replicas=%d```",		// Add manual reactivation instructions		}			},				Value: action.Policy,				Text:  "ðŸ“„ View Policy",				Type:  "button",			{			},				Style: "primary",				Value: fmt.Sprintf("%s/%s", deployment.Namespace, deployment.Name),				Text:  "â¯ï¸ Reactivate Now",				Type:  "button",			{		attachment.Actions = []SlackAction{	if !action.DryRun {	// Add reactivation button if not dry-run	}		Footer:    "FinOps Enforcer",		Timestamp: time.Now().Unix(),		Fields:    fields,		Text:      action.Reason,		Title:     title,		Color:     "#ff9900",	attachment := SlackAttachment{	}		},			Short: true,			Value: action.Policy,			Title: "Policy",		{		},			Short: true,			Value: fmt.Sprintf("$%.2f", action.EstimatedMonthlySavings),			Title: "Estimated Monthly Savings",		{		},			Short: true,			Value: fmt.Sprintf("%d", action.OriginalReplicas),			Title: "Original Replicas",		{		},			Short: true,			Value: idleDuration,			Title: "Idle Duration",		{		},			Short: true,			Value: deployment.Name,			Title: "Deployment",		{		},			Short: true,			Value: deployment.Namespace,			Title: "Namespace",		{	fields := []SlackField{	}		title = "ðŸ§ª DRY-RUN: Would Pause Idle Resource"	if action.DryRun {	title := "ðŸš¨ Idle Resource Paused"	}		}			idleDuration = formatDuration(time.Since(lastActivity))		if lastActivity, err := time.Parse(time.RFC3339, lastActivityStr); err == nil {	if lastActivityStr := deployment.Annotations["finops.io/last-activity"]; lastActivityStr != "" {	idleDuration := "Unknown"	// Calculate idle duration from annotations		deployment := action.Deploymentfunc (s *SlackNotifier) buildPauseMessage(action *policy.EnforcementAction) *SlackMessage {// buildPauseMessage constructs a Slack message for pause notifications}	return s.sendMessage(ctx, message)	message := s.buildReactivationMessage(namespace, deployment, replicas)func (s *SlackNotifier) NotifyReactivation(ctx context.Context, namespace, deployment string, replicas int32) error {// NotifyReactivation sends a notification about a reactivated resource}	return s.sendMessage(ctx, message)	message := s.buildPauseMessage(action)func (s *SlackNotifier) NotifyPause(ctx context.Context, action *policy.EnforcementAction) error {// NotifyPause sends a notification about a paused resource}	}		},			Timeout: 10 * time.Second,		httpClient: &http.Client{		channel:    channel,		webhookURL: webhookURL,	return &SlackNotifier{func NewSlackNotifier(webhookURL, channel string) *SlackNotifier {// NewSlackNotifier creates a new Slack notifier}	httpClient *http.Client	channel    string	webhookURL stringtype SlackNotifier struct {// SlackNotifier sends notifications to Slack)	"github.com/yourusername/finops-enforcer/pkg/policy"