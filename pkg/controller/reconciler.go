package controller
package controller

import (
	"context"
	"fmt"
	"time"

	finopsv1alpha1 "github.com/yourusername/finops-enforcer/api/v1alpha1"
	"github.com/yourusername/finops-enforcer/pkg/cost"
	"github.com/yourusername/finops-enforcer/pkg/enforcement"
	"github.com/yourusername/finops-enforcer/pkg/metrics"
	"github.com/yourusername/finops-enforcer/pkg/notifications"
	"github.com/yourusername/finops-enforcer/pkg/policy"
	appsv1 "k8s.io/api/apps/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
)















































































































































































































































































}		Complete(r)		For(&finopsv1alpha1.EnforcementPolicy{}).	return ctrl.NewControllerManagedBy(mgr).func (r *EnforcementPolicyReconciler) SetupWithManager(mgr ctrl.Manager) error {// SetupWithManager sets up the controller with the Manager}	return pattern == value		}		return len(value) >= len(prefix) && value[:len(prefix)] == prefix		prefix := pattern[:len(pattern)-1]	if len(pattern) > 0 && pattern[len(pattern)-1] == '*' {	// Simple suffix match for patterns like "dev-*"		}		return true	if pattern == "*" {func matchWildcard(pattern, value string) bool {// matchWildcard performs simple wildcard matching}	return true	}		}			}				return false			if deployment.Labels[key] != value {		for key, value := range scope.Labels.Match {		// Check required matches		}			}				return false			if deployment.Labels[key] == value {		for key, value := range scope.Labels.Exclude {		// Check exclusions first	if scope.Labels != nil {	// Check label filters if specified	}		}			return false		if matchWildcard(pattern, deployment.Namespace) {	for _, pattern := range scope.Namespaces.Exclude {	// Check namespace exclusions	}		return false	if !namespaceMatches {	}		}			break			namespaceMatches = true		if matchWildcard(pattern, deployment.Namespace) {	for _, pattern := range scope.Namespaces.Include {	namespaceMatches := false	// Check namespace filters) bool {	scope finopsv1alpha1.ScopeSpec,	deployment appsv1.Deployment,func (r *EnforcementPolicyReconciler) matchesScope(// matchesScope checks if a deployment matches policy scope}	return filtered, nil	}		}			filtered = append(filtered, deployment)		if r.matchesScope(deployment, policy.Spec.Scope) {	for _, deployment := range deploymentList.Items {	filtered := []appsv1.Deployment{}	// Filter by namespace scope	}		return nil, fmt.Errorf("failed to list deployments: %w", err)	if err := r.List(ctx, deploymentList); err != nil {	deploymentList := &appsv1.DeploymentList{}	// Get all deployments) ([]appsv1.Deployment, error) {	policy *finopsv1alpha1.EnforcementPolicy,	ctx context.Context,func (r *EnforcementPolicyReconciler) getDeploymentsInScope(// getDeploymentsInScope returns all deployments matching policy scope}	return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil	// Requeue after 5 minutes	)		"duration", time.Since(startTime),		"actions_taken", actionsPerformed,		"matched", matchedCount,		"policy", policyObj.Name,	logger.Info("reconciliation complete",	metrics.ReconciliationDuration.Observe(time.Since(startTime).Seconds())	// Record reconciliation duration	}		logger.Error(err, "failed to update policy status")	if err := r.Status().Update(ctx, policyObj); err != nil {	policyObj.Status.EstimatedSavings += totalSavings	policyObj.Status.ActionsPerformed += actionsPerformed	policyObj.Status.MatchedResources = matchedCount	policyObj.Status.LastEvaluationTime = &ctrl.Now()	// Update policy status	}		)			"dry_run", action.DryRun,			"estimated_monthly_savings", action.EstimatedMonthlySavings,			"namespace", action.Deployment.Namespace,			"deployment", action.Deployment.Name,			"action", action.Type,		logger.Info("enforcement action executed",		}			}				)					"deployment", action.Deployment.Name,				logger.Error(err, "failed to send slack notification",			if err := r.Notifier.NotifyPause(ctx, action); err != nil {		if policyObj.Spec.Actions.Notify == finopsv1alpha1.NotifyTypeSlack && r.Notifier != nil {		// Send notification		}			)				action.EstimatedMonthlySavings,				action.Policy,				action.Deployment.Namespace,			metrics.RecordPausedResource(		if !action.DryRun {		metrics.RecordAction(string(action.Type), action.Deployment.Namespace, action.DryRun)		// Record metrics		totalSavings += action.EstimatedMonthlySavings		actionsPerformed++		}			continue			)				"namespace", action.Deployment.Namespace,				"deployment", action.Deployment.Name,			logger.Error(err, "failed to execute action",		if err := r.Enforcer.ExecuteAction(ctx, action); err != nil {	for _, action := range actionsToTake {	totalSavings := 0.0	actionsPerformed := 0	// Execute actions	}		actionsToTake = actionsToTake[:maxActions]		)			"max_allowed", maxActions,			"total_matched", len(actionsToTake),		logger.Info("limiting actions per run",	if len(actionsToTake) > maxActions {	}		maxActions = policyObj.Spec.Enforcement.MaxActionsPerRun	if policyObj.Spec.Enforcement.MaxActionsPerRun > 0 {	maxActions := r.MaxActionsPerRun	// Apply max actions limit	}		)			"reason", result.Reason,			"matched", result.Matched,			"namespace", deployment.Namespace,			"deployment", deployment.Name,		logger.V(1).Info("policy evaluation result",		}			}				actionsToTake = append(actionsToTake, result.Action)			if result.Action != nil {						metrics.RecordPolicyMatch(policyObj.Name, string(policyObj.Spec.Actions.Type))			matchedCount++		if result.Matched {		}			continue			)				"namespace", deployment.Namespace,				"deployment", deployment.Name,			logger.Error(err, "policy evaluation failed",		if err != nil {		result, err := r.PolicyEngine.Evaluate(ctx, policyObj, deployment, costData)		// Evaluate policy		}			continue			metrics.OpenCostAPIErrors.Inc()			)				"namespace", deployment.Namespace,				"deployment", deployment.Name,			logger.Error(err, "failed to get cost data",		if err != nil {		)			policyObj.Spec.Conditions.IdleWindow.Duration,			deployment.Name,			deployment.Namespace, 		costData, err := r.CostClient.GetDeploymentCost(ctx, 		// Get cost data for this deployment		deployment := &deployments[i]	for i := range deployments {	matchedCount := 0	actionsToTake := []*policy.EnforcementAction{}	// Evaluate each deployment against policy	)		"count", len(deployments),		"policy", policyObj.Name,	logger.Info("found deployments in scope",	}		return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil		metrics.PolicyEvaluationErrors.WithLabelValues(policyObj.Name).Inc()		logger.Error(err, "failed to get deployments in scope")	if err != nil {	deployments, err := r.getDeploymentsInScope(ctx, policyObj)	// Get all deployments in scope	}()		metrics.PolicyEvaluationDuration.WithLabelValues(policyObj.Name).Observe(duration)		duration := time.Since(evalStart).Seconds()	defer func() {	evalStart := time.Now()	// Track policy evaluation duration	)		"namespace", policyObj.Namespace,		"policy", policyObj.Name,	logger.Info("reconciling enforcement policy",	}		return ctrl.Result{}, client.IgnoreNotFound(err)	if err := r.Get(ctx, req.NamespacedName, policyObj); err != nil {	policyObj := &finopsv1alpha1.EnforcementPolicy{}	// Fetch the EnforcementPolicy	startTime := time.Now()	logger := log.FromContext(ctx)func (r *EnforcementPolicyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {// +kubebuilder:rbac:groups="",resources=pods,verbs=get;list;watch// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;update;patch// +kubebuilder:rbac:groups=finops.io,resources=enforcementpolicies/status,verbs=get;update;patch// +kubebuilder:rbac:groups=finops.io,resources=enforcementpolicies,verbs=get;list;watch;update;patch// Reconcile implements the reconciliation loop}	MaxActionsPerRun int	Notifier      *notifications.SlackNotifier	Enforcer      *enforcement.Executor	PolicyEngine  *policy.Engine	CostClient    *cost.Client	Scheme        *runtime.Scheme	client.Clienttype EnforcementPolicyReconciler struct {// EnforcementPolicyReconciler reconciles an EnforcementPolicy object