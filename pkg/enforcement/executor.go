package enforcement
package enforcement

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/yourusername/finops-enforcer/pkg/policy"
	appsv1 "k8s.io/api/apps/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"





















































































































































}	return paused, nil	}		}			paused = append(paused, deployment)		if deployment.Annotations["finops.io/paused"] == "true" {	for _, deployment := range deploymentList.Items {	paused := []appsv1.Deployment{}	}		return nil, fmt.Errorf("failed to list deployments: %w", err)	if err := e.client.List(ctx, deploymentList, listOpts...); err != nil {	}		listOpts = append(listOpts, client.InNamespace(namespace))	if namespace != "" {	listOpts := []client.ListOption{}		deploymentList := &appsv1.DeploymentList{}func (e *Executor) GetPausedDeployments(ctx context.Context, namespace string) ([]appsv1.Deployment, error) {// GetPausedDeployments returns all deployments paused by FinOps Enforcer}	return nil	)		"replicas", originalReplicas,		"namespace", namespace,		"deployment", name,	logger.Info("successfully reactivated deployment",	}		return fmt.Errorf("failed to reactivate deployment: %w", err)	if err := e.client.Update(ctx, deployment); err != nil {	// Update deployment	deployment.Annotations["finops.io/last-reactivation"] = time.Now().Format(time.RFC3339)	// Keep original-replicas for historical tracking		delete(deployment.Annotations, "finops.io/paused-at")	delete(deployment.Annotations, "finops.io/paused")	// Clean up pause annotations	deployment.Spec.Replicas = &replicas	replicas := int32(originalReplicas)	// Restore replicas	}		return fmt.Errorf("invalid original-replicas value: %w", err)	if err != nil {	originalReplicas, err := strconv.ParseInt(originalReplicasStr, 10, 32)	}		return fmt.Errorf("missing original-replicas annotation")	if originalReplicasStr == "" {	originalReplicasStr := deployment.Annotations["finops.io/original-replicas"]	// Read original replica count	}		return fmt.Errorf("deployment %s/%s is not paused", namespace, name)	if deployment.Annotations["finops.io/paused"] != "true" {	// Verify it's actually paused	}		return fmt.Errorf("failed to get deployment: %w", err)	}, deployment); err != nil {		Name:      name,		Namespace: namespace,	if err := e.client.Get(ctx, client.ObjectKey{	deployment := &appsv1.Deployment{}	logger := log.FromContext(ctx)func (e *Executor) ReactivateDeployment(ctx context.Context, namespace, name string) error {// ReactivateDeployment restores a paused deployment to its original state}	return nil	)		"estimated_monthly_savings", action.EstimatedMonthlySavings,		"original_replicas", action.OriginalReplicas,		"namespace", deployment.Namespace,		"deployment", deployment.Name,	logger.Info("successfully paused deployment",	}		return fmt.Errorf("failed to scale deployment to zero: %w", err)	if err := e.client.Update(ctx, deployment); err != nil {	// Update deployment	deployment.Spec.Replicas = &replicas	replicas := int32(0)	// Scale to zero	deployment.Annotations["finops.io/estimated-monthly-savings"] = fmt.Sprintf("%.2f", action.EstimatedMonthlySavings)	deployment.Annotations["finops.io/reason"] = action.Reason	deployment.Annotations["finops.io/policy"] = action.Policy	deployment.Annotations["finops.io/original-replicas"] = strconv.Itoa(int(action.OriginalReplicas))	deployment.Annotations["finops.io/paused-at"] = time.Now().Format(time.RFC3339)	deployment.Annotations["finops.io/paused"] = "true"	}		deployment.Annotations = make(map[string]string)	if deployment.Annotations == nil {	// Store original replica count	deployment := action.Deployment	logger := log.FromContext(ctx)func (e *Executor) scaleToZero(ctx context.Context, action *policy.EnforcementAction) error {// scaleToZero scales a deployment to zero replicas with proper tracking}	}		return fmt.Errorf("unsupported action type: %s", action.Type)	default:		return e.scaleToZero(ctx, action)	case "scaleToZero":	switch action.Type {	}		return nil		)			"reason", action.Reason,			"namespace", action.Deployment.Namespace,			"deployment", action.Deployment.Name,			"action", action.Type,		logger.Info("DRY-RUN: would execute action",	if action.DryRun {	logger := log.FromContext(ctx)func (e *Executor) ExecuteAction(ctx context.Context, action *policy.EnforcementAction) error {// ExecuteAction performs the enforcement action with proper annotation and tracking}	}		client: client,	return &Executor{func NewExecutor(client client.Client) *Executor {// NewExecutor creates a new enforcement executor}	client client.Clienttype Executor struct {// Executor handles enforcement action execution with safety guardrails)	"sigs.k8s.io/controller-runtime/pkg/log"