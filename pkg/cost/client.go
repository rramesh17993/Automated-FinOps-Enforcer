package cost
package cost

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// Client provides access to OpenCost API for real-time cost data
type Client struct {
	endpoint   string
	httpClient *http.Client





























































































































































}	return hourlyCost * 730	// Assume 730 hours per month (365 days / 12 months * 24 hours)func EstimateMonthlyCost(hourlyCost float64) float64 {// EstimateMonthlyCost calculates estimated monthly cost from hourly rate}	return fmt.Sprintf("%dh", hours)	}		return fmt.Sprintf("%dd", hours/24)	if hours%24 == 0 {	hours := int(d.Hours())func formatDuration(d time.Duration) string {// formatDuration converts time.Duration to OpenCost window format}	return results	}		})			Timestamp:  time.Now(),			Labels:     allocation.Properties.Labels,			DailyCost:  hourlyCost * 24,			HourlyCost: hourlyCost,			Deployment: allocation.Properties.Deployment,			Namespace:  allocation.Properties.Namespace,		results = append(results, CostData{		}			hourlyCost = allocation.TotalCost / duration		if duration > 0 {		hourlyCost := 0.0		duration := allocation.End.Sub(allocation.Start).Hours()		// Calculate hourly cost from total cost and time window	for _, allocation := range response.Data {	results := make([]CostData, 0, len(response.Data))func parseOpenCostResponse(response OpenCostResponse) []CostData {// parseOpenCostResponse converts OpenCost API response to our CostData format}	Labels     map[string]string `json:"labels"`	Deployment string            `json:"deployment"`	Namespace  string            `json:"namespace"`	Cluster    string            `json:"cluster"`type AllocationProperty struct {// AllocationProperty contains resource properties}	TotalCost  float64            `json:"totalCost"`	End        time.Time          `json:"end"`	Start      time.Time          `json:"start"`	Properties AllocationProperty `json:"properties"`	Name       string             `json:"name"`type OpenCostAllocation struct {// OpenCostAllocation represents a single cost allocation}	Data []OpenCostAllocation `json:"data"`type OpenCostResponse struct {// OpenCostResponse represents the raw response from OpenCost API}	return nil	}		return fmt.Errorf("health check failed: status=%d", resp.StatusCode)	if resp.StatusCode != http.StatusOK {	defer resp.Body.Close()	}		return fmt.Errorf("health check failed: %w", err)	if err != nil {	resp, err := c.httpClient.Do(req)	}		return fmt.Errorf("failed to create health check request: %w", err)	if err != nil {	req, err := http.NewRequestWithContext(ctx, "GET", c.endpoint+"/healthz", nil)func (c *Client) HealthCheck(ctx context.Context) error {// HealthCheck verifies OpenCost API is accessible}	return nil, fmt.Errorf("no cost data found for deployment %s/%s", namespace, deployment)	}		}			return &cost, nil		if cost.Deployment == deployment {	for _, cost := range costs {	}		return nil, err	if err != nil {	costs, err := c.GetNamespaceCosts(ctx, namespace, window)func (c *Client) GetDeploymentCost(ctx context.Context, namespace, deployment string, window time.Duration) (*CostData, error) {// GetDeploymentCost retrieves cost data for a specific deployment}	return parseOpenCostResponse(response), nil	}		return nil, fmt.Errorf("failed to decode response: %w", err)	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {	var response OpenCostResponse	}		return nil, fmt.Errorf("opencost api error: status=%d, body=%s", resp.StatusCode, string(body))		body, _ := io.ReadAll(resp.Body)	if resp.StatusCode != http.StatusOK {	defer resp.Body.Close()	}		return nil, fmt.Errorf("failed to fetch cost data: %w", err)	if err != nil {	resp, err := c.httpClient.Do(req)	req.URL.RawQuery = q.Encode()	q.Add("filter", fmt.Sprintf("namespace:%s", namespace))	q.Add("aggregate", "namespace,deployment")	q.Add("window", windowStr)	q := req.URL.Query()	}		return nil, fmt.Errorf("failed to create request: %w", err)	if err != nil {	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)	windowStr := formatDuration(window)	// Window format: "2d" for 2 days, "48h" for 48 hours	// Build query parameters for OpenCost API	url := fmt.Sprintf("%s/allocation", c.endpoint)func (c *Client) GetNamespaceCosts(ctx context.Context, namespace string, window time.Duration) ([]CostData, error) {// GetNamespaceCosts retrieves cost data for all resources in a namespace}	Timestamp  time.Time	Labels     map[string]string	DailyCost  float64	HourlyCost float64	Deployment string	Namespace  stringtype CostData struct {// CostData represents cost information for a resource}	}		},			Timeout: timeout,		httpClient: &http.Client{		endpoint: endpoint,	return &Client{func NewClient(endpoint string, timeout time.Duration) *Client {// NewClient creates a new OpenCost client}